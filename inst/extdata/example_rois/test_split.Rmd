```{r}
library(sfnetworks)
library(tidyverse)
library(tidygraph)

devtools::load_all(".")

csv_data <- "Id,Name,Text,type,all_points,X,Y,RadiusX,RadiusY,Width,Height,all_transforms\n1,Polygon1,Polygon1,Polygon,\"35.79,240.02 227.56,397.67 227.56,555.31 259.32,641.19 312.26,717.67 293.44,751.78 227.56,780.02 59.32,688.25 0.5,489.43 0.5,376.49 35.79,240.02\",-1,-1,-1,-1,-1,-1,-1\n2,Polygon2,Polygon2,Polygon,\"251.09,258.15 211.09,351.09 200.78,406.27 213.44,482.85 208.74,559.32 225.94,606.38 316.97,606.38 498.42,629.91 526.38,306.38 418.15,87.56 662.85,42.85 509.91,0.5 273.44,5.21 179.32,40.5 179.32,162.85 251.09,258.15\",-1,-1,-1,-1,-1,-1,-1"

df <- read.csv(text = csv_data, stringsAsFactors = FALSE)

roi_sf <- roi_df_to_sf(df)

int <- sf::st_intersection(roi_sf) %>%
  dplyr::filter(
    purrr::map_lgl(origins, \(x) identical(x, c(1L, 2L)))
  )
# Add additional points along each line segment of the polygon
int_densified <- sf::st_segmentize(int, dfMaxLength = 1)

# find the two points where the two polygons in roi_sf intersect (the edges)
touch_points <- sf::st_intersection(sf::st_cast(roi_sf, "LINESTRING")) %>%
  dplyr::filter(
    purrr::map_lgl(origins, \(x) identical(x, c(1L, 2L)))
  )

sf::st_distance(touch_points, int)

ints <- int_densified[1, ]

v <- sf::st_voronoi(ints, bOnlyEdges = TRUE)

v_edges <- sf::st_cast(v, "LINESTRING")

v_only_interior <- v_edges %>%
  sf::st_filter(int, .predicate = sf::st_within)

plot(sf::st_geometry(int))
plot(sf::st_geometry(v_edges), add = TRUE, lwd = 0.1)
plot(sf::st_geometry(v_only_interior), add = TRUE)

# In case it's a MULTIPOINT in a single row, cast it
touch_pts <- sf::st_cast(touch_points, "POINT")
if (nrow(touch_pts) < 2) {
  stop("Expected at least two touch points, found ", nrow(touch_pts))
}

start_pt <- touch_pts[1, ]
end_pt   <- touch_pts[2, ]

# Find closest points on v_only_interior to start and end points
closest_to_start <- sf::st_nearest_points(start_pt, v_only_interior[sf::st_nearest_feature(start_pt, v_only_interior), ])
closest_to_end <- sf::st_nearest_points(end_pt, v_only_interior[sf::st_nearest_feature(end_pt, v_only_interior), ])

plot(sf::st_geometry(int))
plot(sf::st_geometry(closest_to_start), col = "blue", lwd = 2, add = TRUE)
plot(sf::st_geometry(closest_to_end), col = "red", lwd = 2, add = TRUE)

# Combine with existing v_only_interior
v_with_pts <- bind_rows(
  v_only_interior,
  sf::st_sf(geometry = closest_to_start),
  sf::st_sf(geometry = closest_to_end)
)

# Construct graph
v_graph <- as_sfnetwork(
  v_with_pts,
  directed = FALSE,
  length_as_weight = TRUE
)

# Map the two touch points to nearest network nodes
idx_start <- sf::st_nearest_feature(start_pt, activate(v_graph, "nodes"))
idx_end   <- sf::st_nearest_feature(end_pt, v_graph)

# Compute shortest path
v_shortest <- v_graph %>%
  activate("edges") %>%
  convert(to_spatial_shortest_paths, from = idx_start, to = idx_end)

plot(sf::st_geometry(int), col = rgb(0, 0, 1, alpha = 0.5))
plot(sf::st_geometry(v_shortest), col = "red", lwd = 2, add = TRUE)

# v_shortest_single <- v_shortest %>%
#   activate("edges") %>%
#   sf::st_as_sf() %>%
#   summarise(geometry = sf::st_union(geometry)) %>%
#   sf::st_cast("LINESTRING")
v_shortest_single <- v_shortest %>%
  activate("edges") %>%
  sf::st_as_sf() %>%
  arrange(.tidygraph_edge_index) %>%
  pull(geometry) %>%
  sf::st_combine() %>%
  sf::st_line_merge() %>%
  sf::st_cast("LINESTRING")

plot(sf::st_geometry(int), col = rgb(0, 0, 1, alpha = 0.5))
plot(sf::st_geometry(v_shortest_single), col = "red", lwd = 2, add = TRUE)

extend_linestring <- function(line, d) {
  # extract coordinates matrix (X,Y)
  mat <- st_coordinates(line)[, c("X","Y")]
  if (nrow(mat) < 2) stop("LINESTRING must have at least two vertices")

  # start segment unit vector (p1→p2)
  p1  <- mat[1,]
  p2  <- mat[2,]
  v1  <- p2 - p1
  u1  <- v1 / sqrt(sum(v1^2))

  # end segment unit vector (pn-1→pn)
  pn1 <- mat[nrow(mat)-1,]
  pn  <- mat[nrow(mat),]
  v2  <- pn - pn1
  u2  <- v2 / sqrt(sum(v2^2))

  # compute new endpoints
  new_start <- p1 - u1 * d
  new_end   <- pn + u2 * d

  # assemble extended coordinate list
  new_mat <- rbind(new_start, mat, new_end)

  # return a raw LINESTRING geometry
  st_linestring(new_mat)
}

cut_xy <- extend_linestring(sf::st_geometry(v_shortest_single), 1e-6)

split_and_keep_biggest <- function(poly_row, splitter) {
  # Ensure validity before splitting
  poly_geom <- sf::st_make_valid(poly_row)
  split_geom <- lwgeom::st_split(poly_geom, splitter)
  plot(poly_geom)
  plot(splitter, add = TRUE, col = "red", lwd = 2)
  parts <- sf::st_collection_extract(split_geom, "POLYGON")
  if (length(parts) != 2) {
    stop("Expected 2 parts after splitting, found ", length(parts), ".")
  }
  parts[which.max(sf::st_area(parts)), ]
}

# Perform split for each ROI using the extended cut line
roi_sf_disjoint <- roi_sf %>%
  mutate(
    geometry = purrr::map(
      geometry,
      \(x) split_and_keep_biggest(x, sf::st_geometry(cut_xy))
    ) %>%
      do.call(c, .)
  )

# Optional: verify disjointness
# any(sf::st_overlaps(sf::st_make_valid(roi_sf_disjoint), sparse = FALSE))

# Plot result
plot(sf::st_geometry(roi_sf), col = adjustcolor("skyblue", alpha.f = 0.4), border = NA)
plot(sf::st_geometry(roi_sf_disjoint), add = TRUE, col = c(adjustcolor("#1f77b4", 0.6), adjustcolor("#ff7f0e", 0.6)))
plot(sf::st_geometry(cut_xy), add = TRUE, col = "red", lwd = 2)
points(sf::st_geometry(start_pt), col = "green", pch = 19)
points(sf::st_geometry(end_pt), col = "orange", pch = 19)

roi_sf_disjoint
```


```{r}
csv_data <- paste(
  'Id,Name,Text,type,all_points,X,Y,RadiusX,RadiusY,Width,Height,all_transforms',
  '1,Polygon1,Polygon1,Polygon,"102.86,41.71 26.39,115.83 0.51,312.3 38.15,467.59 211.1,494.65 160.51,365.24 198.15,258.18 325.21,238.18 340.51,153.47 206.39,173.47 230.2,86.41 340.51,88.77 306.39,29.94 238.15,0.53 102.86,41.71",-1,-1,-1,-1,-1,-1,-1',
  '2,Polygon2,Polygon2,Polygon,"225.21,422.88 176.98,440.53 141.68,400.53 118.15,360.53 161.68,322.88 155.8,339.36 189.92,342.88 225.21,422.88",-1,-1,-1,-1,-1,-1,-1',
  '3,Polygon3,Polygon3,Polygon,"265.21,286.41 366.39,247.59 355.8,153.47 340.51,132.3 287.57,132.3 258.15,174.65 306.39,179.36 302.86,209.36 264.04,227.59 247.57,267.59 265.21,286.41",-1,-1,-1,-1,-1,-1,-1',
  '4,Polygon4,Polygon4,Polygon,"272.27,433.47 225.21,437 205.21,409.94 230.2,374.65 230.2,347.59 189.92,361.71 180.51,347.59 200.51,312.3 255.8,329.94 295.8,399.36 272.27,433.47",-1,-1,-1,-1,-1,-1,-1',
  sep = "\n"
)

roi_sf <- read.csv(text = csv_data, stringsAsFactors = FALSE) %>%
  roi_df_to_sf()

resolved <- resolve_polygon_overlaps(
  roi_sf
)

csv_data <- "Id,Name,Text,type,all_points,X,Y,RadiusX,RadiusY,Width,Height,all_transforms\n1,Polygon1,Polygon1,Polygon,\"35.79,240.02 227.56,397.67 227.56,555.31 259.32,641.19 312.26,717.67 293.44,751.78 227.56,780.02 59.32,688.25 0.5,489.43 0.5,376.49 35.79,240.02\",-1,-1,-1,-1,-1,-1,-1\n2,Polygon2,Polygon2,Polygon,\"251.09,258.15 211.09,351.09 200.78,406.27 213.44,482.85 208.74,559.32 225.94,606.38 316.97,606.38 498.42,629.91 526.38,306.38 418.15,87.56 662.85,42.85 509.91,0.5 273.44,5.21 179.32,40.5 179.32,162.85 251.09,258.15\",-1,-1,-1,-1,-1,-1,-1"

df <- read.csv(text = csv_data, stringsAsFactors = FALSE)

roi_sf <- roi_df_to_sf(df)

resolved <- resolve_polygon_overlaps(
  roi_sf
)

```
